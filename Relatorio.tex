\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}
\usepackage{a4wide}
\usepackage{multicol}
\usepackage{spverbatim}
\usepackage{graphicx}

\title{Projeto de LI3 - Wikipedia\\Grupo 69}
\author{Sérgio Jorge (A77730) \and Vítor Castro (A77870) \and Marcos Pereira (A79116)}
\date{}


\begin{document}

\maketitle

\begin{abstract}
Neste relatório faremos uma análise do trabalho realizado na primeira fase do projeto de Laboratórios de Informática III no qual, surgiu o objetivo de desenvolver um programa tendo por base a linguagem de programação C. Além disso, o relatório apresenta também a solução encontrada pelo nosso grupo para o problema.
\end{abstract}

\tableofcontents

\section{Introdução}
\label{sec:intro}
Este projeto foi realizado com o objetivo de construir um aplicativo que capaz de fazer uma análise dos artigos que estão nos backups da Wikipedia, fornecidos pelos professores e que foram realizados em diferentes meses, para que seja possível determinar e descobrir informações úteis acerca desses mesmos backups.
Assim, foram propostas pelos professores, 10 interrogações ou tarefas computacionais, realizadas na linguagem de programação C, às quais o nosso programa e o nosso trabalho devem responder com sucesso. A realização das 10 tarefas permitiram por um lado, melhorar e consolidar os conhecimentos adquiridos nas UCs de Programação Imperativa, Algoritmos e Complexidade e Arquitetura de Computadores. Por outro, permitiram também a aprendizagem de processos para a correta resolução de problemas tal como a divisão do projeto em alguns módulos afim de ser possível que todos os membros do grupo conseguissem ajudar à concretização do projeto de igual forma.
Assim, de modo a facilitar a compreensão do projeto, o relatório está dividido da seguinte forma:
\begin{description}
    \item[Secção 2 :] Problema;
    \item[Secção 3 :] Solução;
    \item[Secção 4 :] Conclusão.
\end{description}

\section{Problema}
\label{sec:problema}
Neste projeto de LI3, é-nos pedido para a partir de backups da Wikipedia, fornecidos pelos professores, fazermos a leitura dos dados e a extração de informação que a equipa docente considera relevante. Assim, a informação que devemos gerar é:	
\begin{description}
\item[1 - All articles]\hfill \\ 
devolver o número de artigos encontrados nos backups.
\item[2 - Unique articles]\hfill \\ 
devolver o número de artigos únicos (com id único) encontrados nos vários backups analisados.
\item[3 - All revisions]\hfill \\
devolver quantas revisoões foram efetuadas nos backups.
\item[4 - Top 10 contributors]\hfill \\
devolver um array com os identificadores dos 10 autores que contribuíram para um maior numero de revisões de artigos (i.e., contar contribuições para artigos e respetivas revisões). O resultado deve ser ordenado pelos autores com mais contribuições. Se existirem autores com o mesmo número de contribuições, o resultado deve apresentar primeiro os autores com um identificador menor.
\item[5 - Contributor name]\hfill \\
devolver o nome do autor com um determinado identificador.
\item[6 - Top 20 largest articles]\hfill \\
devolver um array com os identificadores dos 20 artigos que possuem textos com um maior tamanho em bytes. Para cada artigo deve ser contabilizado o maior texto encontrado nas diversas versões(revisões) do mesmo. O resultado deve ser ordenado pelos artigos com maior tamanho. Se existirem artigos com o mesmo tamanho, o resultado deve apresentar primeiro os artigos com um identificador menor
\item[7 - Article title]\hfill \\
devolver o título do artigo com um determinado identificador.
\item[8 - Top N articles with more words]\hfill \\
devolver um array com os identificadores dos N (passado como argumento) artigos que possuem textos com o maior numero de palavras e o resultado deve ser ordenado pelos artigos com maior numero de palavras.
\item[9 - Titles with prefix]\hfill \\
devolver um array de títulos de artigos que começam com um prefixo passado como argumento e o resultado deve ser ordenado por ordem alfabética.
\item[10 - Article timestamp]\hfill \\
devolver o timestamp para uma certa revisão de um artigo.
\end{description}

\section{Solução}
A nossa solução foi implementada com base em diferentes módulos dos quais destacamos dois essenciais:

\begin{itemize}
    \item Parser;
    \item Hashtable.
\end{itemize}
\label{sec:solucao}

\subsection{Parser}
Módulo que funciona com base na biblioteca libxml2. A libxml2 é uma biblioteca para a linguagem C que nos permite trabalhar com ficheiros .xml .
Assim, é-nos então possível percorrer o ficheiro, iterar pelas páginas, e fazer o parse extraindo elementos como: Title, ID e Revision (a cada Revision está associado: ID, ParentId, Timestamp, ContributorId, ContributorUsername, Text).
A informação vai sendo transferida para a memória/hashtables criadas, para o efeito, pelo módulo hashtables explicado de seguida.

\subsection{Hashtables}
Módulo que atráves do uso da biblioteca glib, armazena os dados transmitidos pelo parser... optamos pela uso de 3 tipos de hashtables.
\begin{description}
    \item[Hashtable de articles] Esta estrutura de dados, para cada "artigo", armazena o ID do artigo, o tamanho do texto em bytes, o número de palavras do texto, o título e cria uma hashtable de revisions e insere sempre lá a revisão. No caso de o artigo já existir no sistema, supõe-se então que a hash de revisões já foi anteriormente criada pelo faz-se apenas a inserção da revisão. Além disso, guarda também dois pointers (articleFound e articleUpdated) que se tornam essenciais para uma efetiva e correta contagem do número total de artigos, do número único de artigos e do número total de revisões.
    
    O tamanho do texto em bytes e o número de palavras do texto são calculados a partir de uma função 2 em 1 que, percorre o texto, recorrendo a um contador, e as palavras são então contadas e o contador devolve-nos o tamanho do texto.
	\item[Hashtable de revisions] Cada artigo tem a ele associado uma estrutura de dados deste tipo com as revisões.
	\item[Hashtable de users] Esta estrutura de dados, para cada "artigo", armazena o ID do contributor, o username do contributor e o seu número de contribuições. Faz-se também o uso de um pointer (userWasFound) para informar se o utilizador foi encontrado ou não na hash de utilizadores. Para o caso de surgir um contribuidor que já contribuiu antes, é apenas feito um incremento no seu número de contribuições.

\end{description}

\subsection{Implementação}

\subsubsection{All articles, Unique articles e All revisions}
Para resolvermos estas interrogações, optamos por utilizar dois pointers (articleFound e articleUpdated), que são associados a cada artigo aquando da inserção da informação nas hashs e que, posteriormente, nos dizem o que aconteceu com aquele artigo. 
Assim, sempre que se recebe um artigo, verifica-se se este já existe na estrutura de dados:
Se não existe, Articlefound = 0 e Articleupdated = 1 e, cria o novo artigo na hashtable de artigos, cria a hashtable de revisões e adiciona a revisão à hashtable de revisões.
Se o artigo já existe na estrutura de dados, Articlefound = 1 e verifica-se o que surgiu de diferente no artigo... Então, se de facto surgiram alterações ao artigo, Articleupdated = 1. Senão, Articleupdated = 0. Além disso, a revisão é introduzida na hashtable de revisões do artigo em questão.
Portanto, All articles é alcançado a partir de um contador que é incrementado sempre que uma nova revisão chega ao sistema. Unique articles é devolvido a partir de um contador que é incrementado se e só se o Articlefound está com valor 0. All revisions é calculado também a partir de um contador que é incrementado quando o Articleupdated = 1.

\subsubsection{Top 10 contributors}
Definimos um array com 10 posições para colocar o top. Percorremos a hash de utilizadores e, para cada user, vamos buscar o seu número de contribuições e comparamos se tem mais que o utilizador que está na última posição do top (índice 9). Em caso afirmativo, comparamos com as sucessivas posições, encontramos a posição e deslizamos o resto dos utilizadores para haver lugar para o current. Para os casos em que temos igual número de contribuições na comparação, faz-se um string compare dos dois ID dos users para sabermos qual o menor ID.

\subsubsection{Contributor name}
É devolvido percorrendo a hashtable de utilizadores e verificando se o ID do contributor dado como argumento mapeia na estrutura. Em caso afirmativo, retorna-se o username do contributor. Em caso negativo, retorna-se NULL.

\subsubsection{Top 20 largest articles}
Definimos um array com 20 posições para colocar o top. Percorremos a hash de artigos e, para cada artigo, vamos buscar o número do texto em bytes e comparamos se tem mais que o artigo que está na última posição do top (índice 19). Em caso afirmativo, comparamos com as sucessivas posições, encontramos a posição e deslizamos o resto dos artigos para haver lugar para o current. Para os casos em que temos igual número de contribuições na comparação, faz-se um string compare dos dois ID dos articles para sabermos qual o menor ID.

\subsubsection{Article title}
É devolvido percorrendo a hashtable de artigos e verificando se o ID do artigo dado como argumento mapeia na estrutura. Em caso afirmativo, retorna-se o título do artigo. Em caso negativo, retorna-se NULL.

\subsubsection{Top N articles with more words}
Definimos um array com n posições para colocar o top. Percorremos a hash de artigos e, para cada artigo, vamos buscar o número de palavras e comparamos se tem mais que o artigo que está na última posição do top (índice n-1). Em caso afirmativo, comparamos com as sucessivas posições, encontramos a posição e deslizamos o resto dos artigos para haver lugar para o current. Para os casos em que temos igual número de contribuições na comparação, faz-se um string compare dos dois ID dos articles para sabermos qual o menor ID.

\subsubsection{Titles with prefix}
A forma que encontramos para resolver este problema foi implementar uma função que verifica se determinada string é prefixo de outra string. Assim, percorremos a hashtable de artigos e chamamos a função implementada e verificamos se os títulos são prefixo. Em caso afirmativo, inserimos o título num array definido para o efeito de armazenar todos os títulos com o prefixo dado como argumento. Posteriormente, o array de títulos é ordenado por ordem alfabética.

\subsubsection{Article timestamp}
É devolvido percorrendo a hashtable de artigos e verificando se o ID do artigo dado como argumento mapeia na estrutura. Em caso afirmativo, vai-se à hashtable de revisões e percorremos verificando se o ID da revisão dado como argumento mapeia na estrutura. Em caso afirmativo, retorna-se o timestamp da revisão. Em caso negativo, retorna-se NULL.

\subsection{Resultado Final}

\begin{figure}[htbp]
    \centering
    \includegraphics[width = 420pt, height = 230pt]{output}
\end{figure}

\section{Conclusões}
\label{sec:conclusao}
Este projeto serviu para aprofundarmos o conhecimento da linguagem C, assim como as bibliotecas que lhe estão associadas. Achámos que, com a realização de um trabalho deste tipo permite uma consolidação proveitosa da linguagem, não só em termos teóricos como também em termos práticos e acaba por ser uma forma diferente de cimentar os conteúdos de algumas das UCs que nos surgiram neste curso. Permite também melhorar as habilidades na resolução de problemas. Concluímos também que:

\begin{itemize} 
        \item Hoje em dia, é possível ler e manipular grandes quantidades de informação em poucos segundos;
 	    \item A separação do trabalho em módulos ajuda a dividir o trabalho pela equipa e também, neste contexto, ressalta-se também a utilidade que encontramos no "git";
\end{itemize}

\end{document}